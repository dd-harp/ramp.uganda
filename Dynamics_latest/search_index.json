[["basic-malaria-models.html", "2 Basic Malaria Models", " 2 Basic Malaria Models Ross was interested in understanding malaria so he could make plans about malaria control. Given his interests in measuring malaria, he immediately noticed the importance of the fact that malaria prevalence differed from place to place. He was interested in understanding what caused differences in malaria prevalence. He attributed to differences in exposure to infectious mosquitoes, and parasite transmission from human populations to mosquito populations and back. He knew that the level of prevalence was only partly related to local mosquito populations, since malaria could be acquired elsewhere (e.g. while traveling). He also knew that malaria was affected by human demography, including births, deaths, and migration. His first models ignored these factors and focused on the processes that would affect changes in malaria prevalence over time. The key insight was to try and describe how malaria prevalence changes over time. Prevalence could change through infection and loss of infection. Prevalence of infection in a human population would balance out these two processes. The quantitative logic looks like this: \\[ \\left[ \\begin{array}{rcl} \\mbox{Fraction Infected Today} &amp;=&amp; \\mbox{Fraction Infected Yesterday} \\;\\; \\\\ &amp;-&amp; \\mbox{Fraction Infected that Cleared Infection}\\\\ &amp;+&amp; \\mbox{Fraction Uninfected that Got Infected}\\\\ \\end{array} \\right] \\] The fraction infected would not change if the fraction of infected individuals clearing an infection equaled the fraction of uninfected population getting infected. The formula ignores human demography, including infected people who died, infected people who emigrated, and infected people who immigrated. The model is neither comprehensive nor perfect. It was simple on purpose – the goal was to focus attention on a process. In this form, it does not matter where the humans were infected. For the logic to work out with the next part, however, we must also ignore exposure to malaria away from here. Short-lived mosquitoes are much more likely to die than to clear infections. So for mosquitoes, the process is slightly different: \\[ \\left[ \\begin{array}{rcl} \\mbox{Fraction Infected Today} &amp;=&amp; \\mbox{Fraction Infected Today} \\\\ &amp;-&amp;\\mbox{Fraction of Infected Mosquitoes that Died}\\\\ &amp;+&amp;\\mbox{Fraction of Uninfected Mosquitoes that Got Infected}\\\\ \\end{array} \\right] \\] For this to work with the other equation, the mosquito population remains constant, so every dying infected mosquito with an uninfected one. For this to describe local transmission, it’s important that the two processes are interacting: infectious mosquitoes are infecting people when they bite, and infectious people are infecting mosquitoes when the mosquito blood feeds. This process is clarified by a diagram: We note that this diagram illustrates a cycle. Causal graphs must be acyclic. What is missing from the picture is an arrow showing that causation is played out over time in populations of humans and mosquitoes, as the parasites are transmitted back and forth. To describe the factors that affect malaria transmission and that determine the prevalence of malaria in human populations over time, we will need to use mathematical models. In the following, we will write down four distinct mathematical equations that follow these basic rules: As a deterministic system in discrete time; As a deterministic system in continuous time; As a stochastic system in discrete time; A simulation model in continuous time. In all of these models, we will adhere rigidly to Ross’s simplifying assumptions. At this point, we’re not trying to understand how the malaria models work. Later, we’ll worry about modifying the assumptions to ensure that we have identified and evaluated all the factors that affect malaria in real populations. "],["discrete-time-deterministic.html", "2.1 Discrete Time, Deterministic", " 2.1 Discrete Time, Deterministic We can translate Ross’s basic description of a process into a model, but first, we need to start using mathematical symbols and notation to represent the process. The model itself is formulated as a set of coupled difference equations, but we will write down the equations last. To get there, we must learn about the parts of a model: variables, initial conditions, parameters, and equations. In the following, we also want to write R code to implement and solve the model. We will be adopting some conventions that end up being very useful. So really, this is a lesson about two things. 2.1.1 Variables Variables are quantities that we compute and that change over time. In this model, the variables we compute are the fraction of humans and mosquitoes that are infected at each point in time. Let \\(x_t\\) be the fraction of people who are infected at time \\(t,\\) and \\(0 \\leq x_t \\leq 1.\\) Let \\(y_t\\) be the fraction of mosquitoes who are infected at time \\(t,\\) and \\(0 \\leq y_t \\leq 1.\\) 2.1.2 Initial Conditions Since the values of our variables in the next time step (at time \\(t+1\\)) depend on their values now (at time \\(t\\)), we can’t really compute anything unless we can say how the process gets started. What are the values of our variables at the beginning of our simulations (usually, at time \\(t=0\\))? We set these initial values to be small: # Initial Conditions, as a Named Vector x0 = .01 y0 = .001 xy = c(t=0, x=x0, y=y0) 2.1.3 Parameters The parameters describe the processes that are occurring in the population, the fraction of humans that clear an infection each day, and the fraction of infected mosquitoes that die. Unlike variables, parameters are passed to the model. Let \\(s\\) denote the fraction of people who clear infections after one day; \\(0 &lt; s &lt; 1.\\) Let \\(u\\) denote the fraction of mosquitoes who die in one day; \\(0 &lt; u &lt; 1.\\) Let \\(a\\) denote the fraction of mosquitoes who blood feed on a human in a day; \\(0 &lt; a &lt; 1.\\) Let \\(m\\) denote the number of mosquitoes per human; \\(m \\geq 0.\\) # The Parameters, as a Named Vector par = list( s = 1/200, # The fraction of infections that clear each day u = 1/12, # The fraction of mosquitoes that die each day a = 1/4, # The fraction of mosquitoes that blood feed on a human each day m = 2 # The number of mosquitoes per human ) 2.1.4 Equations Finally, we put all this together into a mathematical statement that has translated the description of a process. There are four terms: The fraction of humans who are infected is \\(x_t\\); a fraction \\(s\\) clear infections. The fraction of mosquitoes who are infected is \\(x_t\\); a fraction \\(u\\) die. The fraction of humans who are infected is \\(1-x_t\\); a fraction \\(m a y_t\\) will become infected. The fraction of mosquitoes who are not infected is \\(1-x_t\\); a fraction \\(a x_t\\) become infected. \\[\\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + m a y_t (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array}\\] We write a function that computes and returns the updated values of the variables. We adopt a simple naming convention: since this is a discrete time system, we will call the function dts_xy_1. It accepts the variables, which describe the state of the system at the current time (as a named vector) and the parameter values (as a list) and it returns the state of the system (as a named vector): dts_xy_1 = function(xy, p){with(as.list(xy), with(p,{ xn = x + m*a*y*(1-x) - s*x yn = y + a*x*(1-y) - u*y return(c(t=t+1, x=xn, y=yn)) }))} 2.1.5 Simulation With the R code we developed, we can now compute the values of the variables after one time step. We initialize xy to hold the computed variables over time. # xy_t stores the values of the variables xy_t = xy We name the variables so that later we can call them by name. # Compute and store the values of the variables xy = dts_xy_1(xy, par) xy_t = rbind(xy_t, xy) We can take a peak at the values we computed: # Print print(xy) ## t x y ## 1.000000000 0.010445000 0.003414167 We can iterate over many time steps, storing the values in columns: # Iterate to compute the values as they change over time for(t in 2:40){ xy = dts_xy_1(xy, par) xy_t = rbind(xy_t, xy) } The way we implemented this, the values of \\(x\\) and \\(y\\) are stored in columns: print(tail(xy_t, 3)) ## t x y ## xy 38 0.9865573 0.7465869 ## xy 39 0.9866426 0.7468730 ## xy 40 0.9866975 0.7470700 We can now plot out the values over the first 40 days with(data.frame(xy_t),{ plot(t, x, type = &quot;b&quot;, ylim = c(0,1), col = &quot;darkgreen&quot;, ylab = &quot;x, y&quot;, xlab = &quot;Time&quot;, pch=15) lines(t, y, type = &quot;b&quot;, col = &quot;darkorange&quot;, pch =19) }) After 40 days, the values of \\(x\\) and \\(y\\) are not changing very much: # The last value is still stored as xy; the [-1] omits t xy[-1] - dts_xy_1(xy, par)[-1] ## x y ## -3.545225e-05 -1.355019e-04 If we iterate another hundred days and check again, the differences are effectively zero. for(i in 41:140){ xy = dts_xy_1(xy, par) xy_t = rbind(xy_t, xy) } xy[-1] - dts_xy_1(xy, par)[-1] ## x y ## 0 0 After simulating, the variables reach a steady state, where asymptotically \\(x_{t+1} = x_t\\) and \\(y_{t+1} = y_t\\). 2.1.6 Analysis We can figure out the steady state values are by substituting \\(x_{t+1} = x_t = x\\) and \\(y_{t+1} = y_t = y\\) into the equations above, and then solving for \\(x\\) and \\(y\\). \\[ \\begin{array}{rl} x &amp;= x - s x + m a y (1-x) \\\\ y &amp;= y - u y + a x (1-y) \\\\ \\end{array} \\] or even easier: \\[\\begin{array}{rl} m a y (1-x) &amp;= s x \\\\ a x (1 - y) &amp;= u y\\\\ \\end{array}\\] The most obvious solution to these equations is \\(x=y=0,\\) which in these models means that there is no malaria. We call it the disease-free steady state. The equilibrium makes some sense: if there are no infected mosquitoes or infected humans in a deterministic model, there can never be any. There is another solution where malaria is present. We solve the second equation first: \\[y = a x / (u + a x).\\] We can substitute this for \\(x\\) into the first equation to get: \\[m a^2 (1-x) = s (u+ax)\\] and now we solve for \\(x\\) \\[x = \\frac{\\textstyle{ma^2 - su}}{\\textstyle{ma^2 + sa}}\\] We can write a function to compute this steady state: # Compute the steady state find_eq_dts_1 = function(par){with(par,{ xx = (m*a^2 - s*u)/ (m*a^2 + s*a) yy = a*xx/(u+a*xx) c(x=xx,y=yy) })} 2.1.7 Verification We want to get used to double checking everything to avoid inserting mistakes. One way to do this is to find two or more ways of computing the same thing, for verification. If we’ve done everything right, we ought to get the same values for the steady states through our analysis and simulation. xy[-1] ## x y ## 0.9867987 0.7475000 find_eq_dts_1(par) ## x y ## 0.9867987 0.7475000 It’s tempting to look at the printout and assume these two numbers are exactly equal. This is the land of computation, so things won’t be exact. We can simply sum up the absolute values of the differences: verify_dts_1 = function(xy, pars){ sum(abs(xy[-1] - find_eq_dts_1(pars))) } verify_dts_1(xy, par) ## [1] 3.330669e-16 If we wanted to reduce this to a simple error check, we should pick a tolerance level – say \\(10^{-9}\\) – and then just ask if we are closer than that: check_it_dts_1 = function(xy, pars, tol=1e-9) { verify_dts_1(xy, pars) &lt; tol } check_it_dts_1(xy, par) ## [1] TRUE 2.1.8 Packaging Workflows If we want to repeat tasks, we can simply write a wrapper around other functions that expedite the work. In this case, we want to write a function that solves the equations (i.e. that iteratively computes and stores the values) over some time interval: solve_dts_xy_1 = function(pars, x0=.01, y0 = 0.001, tmax=100){ xy = c(t=0, x=x0, y=y0) xy_t = xy for(t in 1:tmax){ xy = dts_xy_1(xy, pars) xy_t = rbind(xy_t, xy) } return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } We can write another function that plots the equations (i.e. that iteratively computes and stores the values) over some time interval: plot_xy = function(xy_t, add_points = FALSE){with(xy_t,{ llty = &quot;l&quot; if(add_points == TRUE) llty = &quot;b&quot; plot(t, x, type = llty, ylim = c(0,1), col = &quot;darkgreen&quot;, ylab = &quot;x, y&quot;, xlab = &quot;Time&quot;, pch=15) lines(t, y, type = llty, col = &quot;darkorange&quot;, pch =19) })} Now, all the work we did above can be plotted using a single function call: plot_xy(solve_dts_xy_1(par, tmax=40), add_points=TRUE) Now, it is easier to use the models in various ways. 2.1.9 Thresholds All our analysis worked out well for the parameter values that we chose, but what if we had picked different parameters? There must be some very low level of mosquitoes, for example, where malaria can’t reproduce. If we reduce \\(m\\) to \\(0.005\\) and evaluate the expression at the steady state, we get negative values for \\(x\\) and \\(y\\). par1 = par par1$m = 0.005 find_eq_dts_1(par1) ## x y ## -0.06666667 -0.25000000 What happens if we simulate this? (Let’s set the initial conditions to reasonably high values) plot_xy(solve_dts_xy_1(par1, x0 = .5, y0=.3, tmax=1500)) If we look at the equations, it’s easy enough to spot the problem. Since \\(x\\) and \\(y\\) must be positive, then it must be true that \\[m a^2 &gt; su.\\] We call this a threshold condition. m_crit = with(par, s*u/a^2) m_crit ## [1] 0.006666667 If we check, we find that this gives us the disease free equilibrium. par2 = par par2$m = m_crit find_eq_dts_1(par2) ## x y ## 0 0 2.1.10 Numerical Stability There is another problem with the equations. If we set \\(m\\) too high, such that at some point \\(m a y_t &gt; 1,\\) then the whole system eventually crashes: par3 = par par3$m = 20 plot_xy(solve_dts_xy_1(par3, x0 = .01, y0=.001, tmax=20)) In discrete time formulations, we must be very careful to ensure that we have formulated a proper model. How can we fix this problem? We have to go back to the assumption that the fraction getting infected is linearly proportional to the number of infective bites. One way to do this is to say that the expected number of bites would follow a Poisson distribution with mean \\(may_t,\\) so that the fraction getting infected is the zero term from a Poisson: \\[1 - e^{-m a y_t}\\] Now, our equations are the following: \\[\\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + (1-e^{m a y_t}) (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array}\\] Now, if we want to compute the steady state, we’re stuck with the problem of solving this: \\[(1-e^{-m a^2 x/(u + a x)}) (1-x) = sx\\] It’s surprisingly easy to write down equations, like this one, that we can’t solve with pencil and paper. We can still find a way of computing the steady state, but we have to write R code that solves for \\(x\\) numerically. find_eq_dts_2 = function(pars){with(pars,{ f_xx = function(x, pp){with(pp,{ xx = (1 - exp(-m*a^2*x/(u+a*x)))*(1-x) - s*x y = a*xx/(u+a*xx) yy = u*y + a*xx*(1-y) return(xx^2 + yy^2) })} xx = optimize(f_xx, c(0,1), pp=pars)$min yy = a*xx/(u+a*xx) c(xx, yy) })} The new equilibrium is at: find_eq_dts_2(par3) ## [1] 0.9949026 0.7490406 We can just as easily write the code to numerically solve the discrete time system: dts_xy_2 = function(xy, p){with(as.list(xy), with(p,{ xn = x - s*x + (1-exp(-m*a*y))*(1-x) yn = y - u*y + a*x*(1-y) t=t+1 return(c(t=t, x=xn, y=yn)) }))} Once again, we can wrap a function around the solver so that it’s easier to use the code: solve_dts_xy_2 = function(pars, x0=.01, y0 = 0.001, tmax=100){ xy = c(t=0, x=x0, y=y0) xy_t = xy for(t in 1:tmax){ xy = dts_xy_2(xy, pars) xy_t = rbind(xy_t, xy) } return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } Now, we can visualize the output and see that we have fixed our stability problem. plot_xy(solve_dts_xy_2(par3, x0 = .01, y0=.001, tmax=20)) find_eq_dts_2(par3) ## [1] 0.9949026 0.7490406 solve_dts_xy_2(par3, x0=.1, y0=.05,tmax=300)$last[-1] ## x y ## 0.9949051 0.7490410 Once again, we want to ensure that our code does not have any mistakes, so we write a function to verify our results. verify_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200){ xyt = solve_dts_xy_2(pars, x0=x0, y0=y0, tmax=tmax) sum(abs(xyt$last[-1] - find_eq_dts_2(pars))) } verify_dts_2(par3, tmax=300) ## [1] 2.924525e-06 A function to check that it is accurate to some level of tolerance, but the numerical precision is mismatched, somehow. check_it_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200, tol=1e-5) { verify_dts_2(pars, x0, y0, tmax) &lt; tol } check_it_dts_2(par3, tmax=200) ## [1] TRUE 2.1.11 Notes Some useful notes: The two models we just presented can be implemented in a spreadsheet. We will be using software written in R. "],["continuous-time-deterministic.html", "2.2 Continuous Time, Deterministic", " 2.2 Continuous Time, Deterministic In 1911, Ross formulated his second model as a system of two ordinary differential equations. The model appeared in the \\(2^{nd}\\) edition of The Prevention of Malaria [1], and it also appeared in Nature [2] in this form: \\[ \\begin{array}{rl} dz/dt &amp;= k&#39; z&#39; (p-z) + q z \\\\ dz&#39;/dt &amp;= k z (p&#39;-z&#39;) + q&#39; z&#39; \\\\ \\end{array} \\] At the time, there was not much evidence from malaria research to frame the problem. A fully parameterized model, using biologically meaningful parameters, would have to wait for a few decades of research and a synthesis by Macdonald. In the following, we analyze this system, but we change the variable and parameter names (let \\(z=x\\), \\(z&#39;=y\\), \\(k&#39; = ma\\), \\(k=a\\), \\(r=e^{-s}\\), and \\(p=e^{-g}\\)), to get something that is easier to compare to Macdonald’s model. 2.2.1 Variables \\[ \\begin{array}{rl} dx/dt &amp;= may(1-z) - r x\\\\ dy/dt &amp;= ax(1-y) - g z \\\\ \\end{array} \\] These differential equations require This equation lacks an infective state for mosquitoes. References "],["discrete-time-stochastic.html", "2.3 Discrete Time, Stochastic", " 2.3 Discrete Time, Stochastic "],["continuous-time-stochastic.html", "2.4 Continuous Time, Stochastic", " 2.4 Continuous Time, Stochastic 2.4.1 Deterministic 2.4.2 Stochastic We want to to introduce a mathematical model that is a good starting point. None of the models presented in the previous chapter are suitable, largely because the variables in those models were proportions. The models we will use are almost identical, but the variables are densities. The Ross-Macdonald model is useful as a concise way of understanding malaria transmsission through the parasite’s life-cycle. There is, however, a great deal of complexity that the Ross-Macdonald model does can not address, and some of it matters a great deal in policy. We must extend the model using new mathematical constructs to deal with several features of malaria: malaria immunity and disease in cohorts of humans as they age; human demography; anti-malaria drugs and other pharmaceutical interventions; heterogeneous exposure spatial dynamics and malaria importation; mosquito ecology and behavior; exogenous forcing by weather, giving rise to seasonal and unstable dynamics; and vector control. In the following chapters, we will introduce and critically review the models that have been developed to address these topics in some detail. As we take on these new features and add complexity, we will (in effect) be going around the parasite and mosquito life-cycles over and over again, each time pursuing a new theme. We want to pursue the idea of scaling complexity in dynamic models ranging from simple and abstract to highly realistic. We want to arrive at a happy compromise – a model that is “as simple as possible, but no simpler.” (This is often attributed to Einstein, who probably never said it that way exactly [3]). It might be hard to convince anyone that a model of intermediate complexity is good enough unless at least some of the models have clearly gone too far. We don’t want to add new features to our models unless they would affect some important aspect of malaria transmission dynamics and control. Ideally, we would let the data tell us about the right level of complexity, but how would we ever convince someone to collect the data we need? If we don’t expect to be able to collect all the data, we can do some of the hard work up front to set some prioritize. One way to pursue questions about what details are likely to be biologically relevant is through model building and model-model comparison. If we can’t identify a case where knowing something would change our policies using a mathematical model, it’s probably not worth collecting the data for policy. We think of all these models as crude approximations to a messy reality – the question we want to address is whether the approximations are good enough to use as a basis for giving policy advice. Building very complex models that are also mathematically and biologically sound and meaningful is a daunting task, but we have developed a modular system for building models that streamlines the model building process. To get started, we will reintroduce the Ross-Macdonald model in a form that is easier to extend than the one Macdonald made famous [4]. We will start with a model that first appeared in a 1982 book chapter written by Joan Aron and Robert May [5]. It is a good starting point because it is extensible. We chose it because the variables represent population densities, which are used to compute proportions, like prevalence. In the version of the Ross-Macdonald we presented before (in [Rebuilding Macdonald’s Model]), the variables are proportions. In some models, we would like the total number of hosts to change over space or time, but if our state variables are proportions, then these densities appear in the denominators, which would make them much more difficult to modify. By writing down equations using densities, it is far easier to add complexity. Why use densities? To show why we use densities, we present a simple example. If we write down an equation describing changes in the density of infected humans, \\(X\\), in a population with total human population density \\(H\\). We let \\(V\\) denote vectorial capacity, and \\(b\\) the fraction of infective bites that cause an infection, and we assume the force of infection is \\(bVX/H\\). The dynamics of infection are described by this simple equation: \\[\\frac{dX}{dt} = bV\\frac{X}{H}(H-X)-rX\\] In this equation, prevalence is \\(x = X/H.\\) Following through with the change in variables, we can write down the equation for the change in prevalence: \\[\\frac{dx}{dt} = \\frac{1}{H^2} \\left(H \\frac{dX}{dt} - X \\frac{dH}{dt} \\right)\\] and with some rearranging, we get: \\[\\frac{dx}{dt} = bVx(1-x)-rx -x \\frac{dH}{dt}\\] The second equation is as simple as the first only if \\(dH/dt=0\\). Since we will want to deal with dynamical changes in host populations, we will avoid formulating base models that have proportions. The model is extensible because, as we will see, mosquito population density is a variable, not a term. A parameter in the equation describing changes in mosquito density provides a link to aquatic mosquito ecology, which makes it possible to develop models for mosquito population dynamics, when that is an important consideration. In this version, we find that the formulas describing \\(R_0\\) and vectorial capacity tell the story of parasite transmission through two blood meals. We will thus update the classical formulas. While Macdonald’s analysis and formulas are familiar to many, they were incomplete [6,7]. We develop a formula for vectorial capacity that is consistent with the intent of the original, but our analysis of sensitivity to parameters includes effects on mosquito ecology [8]. (A lengthy and philosophical discussion of the history and its failings is planned.) We chose it because it is realistic. Time does not appear in most versions of the Ross-Macdonald model: the equations are autonomous. These equations use time to drive a seasonal pattern: they are non-autonomous. Since we know we are interested in dealing with exogenous forcing, we start out with a model that is forced. While the following model is basic, we recommend reading it, if only because we introduce concepts and conventions that are important for the software design. References "],["what-is-a-model.html", "2.5 What is a Model?", " 2.5 What is a Model? "],["historical-notes-1.html", "2.6 Historical Notes", " 2.6 Historical Notes If we were simply learning the math, … When we analyze these equations to determine their stability and to identify threshold conditions, we focus on threshold conditions and the behavior of these systems when malaria is rare. In most places, malaria is endemic so we need to be concerned about malaria immunity and its effects on transmission; malaria is under some level of control; and because of weather and other factors, the baseline conditions change from year to year. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
