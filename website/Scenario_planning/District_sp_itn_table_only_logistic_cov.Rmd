---
title: "Working with Models"
output: html_document
---

[`ramp.uganda`](../index.html)

***

load libraries 
This sets locations for `Box/RAMP` and `ramp.uganda` 
```{r}
library(ramp.xds)
library(dplyr)
library(ramp.uganda)
library(ramp.work)
library(ramp.control)
attach(yaml::read_yaml("../../my_paths.yaml")) 
``` 

load district data from district dir
```{r,eval=F}
 load("C:/Users/Admin/Documents/ramp.uganda/data/district_dir.rda")
# #load("C:/Users/doree/Documents/Github/ramp.uganda/data/district_dir.rda")
 dist_name <- sort(district_dir$district_name)
```



Get ITN timelines for all districts that recieved ITN and select only those values that are positive for Post-2015
```{r}
FirstYear <-2015
itn_time <- list()
for (j in dist_name) {
  dates <- get_itn_jdates(j, FirstYear)

  if (!is.null(dates) && length(dates) > 0 && any(dates > 0)) {
    itn_time[[j]] <- sort(dates[dates > 0])
  } 
}
```


load files with fitted models from the box directory
```{r, eval=F}
directory <- paste(box_dir, "models", sep = "") 
eir_files <- list.files(path = directory, pattern = "*_eir_sis.rds", full.names = TRUE)
```


Get pfpr data by district 
```{r,eval=F}
data_list = list()
for(i in dist_name)
  data_list[[i]] <- get_district_pfpr(i)
```

Get fitted models to pfpr data for all the itn district
```{r, eval=F}
fitted_mod <- list()
for (i in 1:length(dist_name)) {
  fitted_mod[[i]] <- readRDS(eir_files[i])
  fitted_mod[[i]]$nHostSpecies <- 1
fitted_mod[[i]]$nVectorSpecies <- 1
}
```

```{r}
percent_eff <- read.csv(file="C:/Users/Admin/Box/RAMP/data/effect_sizes/ITN/malaria_type_itn_eff_2023.csv")
percent_eff$mean_percent[percent_eff$mean_percent < 0] <- 0

```

mean effect by ITN type
```{r}
itn_file_only <- read.csv(file ="C:/Users/Admin/Box/RAMP/data/effect_sizes/ITN/only_itn_eff.csv")
average_eff <- aggregate(mean_percent ~ ITN_Type, data = itn_file_only, FUN = mean)
```


 Profile for obtaining plots and effect sizes

```{r, fig.height=8, fig.width=11}
profile_itn = function(i, model_list, data_list){
  mod_file <- model_list[[i]]
  data <- data_list[[i]]

  #---------------------------------------------------------------------------------------------------
  #get indices from the tt in the trend corresponding to the value after the itn was given out.
  ix <- unique(sapply(itn_time[[i]], function(x) {
  idx <- which(fitted_mod[[i]]$EIRpar$trend_par$tt > x)
  if (length(idx) == 0) {
  return(NA)
} else if (length(idx) >= i) {
  return(idx[i])
} else {
  return(tail(idx, 1))
}
}))
    ##--------------------------------------------------------------------------------------------------
 
   cf_max <- make_cf_base_max(ix, mod_file)
  cf_min <- make_cf_base_min(ix, mod_file)
  cf_median <- make_cf_base_median(ix, mod_file)
  cf_mean <- make_cf_base_mean(ix, mod_file)
  mod1a <- modify_baseline(mod_file, cf_max) 
  mod1b <- modify_baseline(mod_file, cf_min) 
  mod1c <- modify_baseline(mod_file, cf_median) 
  mod1d <- modify_baseline(mod_file, cf_mean) 
  mod_for_cast <- last_to_inits(mod_file)
  mod_for_cast<- forecast_spline_EIR(mod_for_cast, 5,x_last=1)
#  tt1<- seq((ceiling(max(data$jdate)/365)*365)-(365*2),ceiling(max(data$jdate)/365)*365+(5*365), length.out=200)
  tt <- seq(0,ceiling(max(data$jdate)/365)*365+(5*365) ,length.out=200)
  #tt <-  seq(0, (10*365),length.out=200)
  mod_for_cast <- xds_solve_cohort(mod_for_cast, times=tt)

  ## Get outputs for the diffferent models
  vals <- get_XH(mod_file)
  vals1a <- get_XH(mod1a)
  vals1b <- get_XH(mod1b)
  vals1c <- get_XH(mod1c)
  vals1d <- get_XH(mod1d)
  vals_for <- get_XH(mod_for_cast)

 # Time cutoff for effect to start
  vals_for <- as.data.frame(vals_for)
  time_years <- vals_for$time/365+FirstYear
 # Set layout to 2x2 grid
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1), oma = c(0, 0, 2, 0))  # Outer margin at top for legend

coverage <- c(0.3,0.5,0.8,1)
for (j in coverage) {

  # === Decay and PR calculation ===
  #coverage <- 0.3
  itn_type_eff <- 0.9
  effect_itn_start <- j*itn_type_eff
  effect_itn_end <- 0.01
  decay_start <- 2023
  decay_end <- 2026
  t0 <- (decay_start + decay_end) / 2
  t01 <- (decay_start + 3 + decay_end + 3) / 2
  k <- 1.5

  effect_decay <- function(t, e0, e1, k_eff, t0_eff) {
   e1 + (e0 - e1) / (1 + exp(k_eff * (t - t0_eff)))
  }
  
 # cov_opts <- list(
  #F_season =  function(t, e0, e1, k_eff, t0_eff) {
  #  e1 + (e0 - e1) / (1 + exp(k_eff * (t - t0_eff)))
#})


  logistic_pr_with_effect_decay <- function(t, pr0, e0, e1, k_eff, t0_eff, k_pr, t0_pr) {
    effect_t <- effect_decay(t, e0, e1, k_eff, t0_eff)
    pr0 * (1 - (effect_t / (1 + exp(-k_pr * (t - t0_pr)))))
  }
#itn_mod <- setup_bednets(mod_file,
#     coverage_name = "func", coverage_opts = cov_opts, 
#     effectsizes_name = "lemenach")

#xds_solve(itn_mod, 1830, dt=15) -> itn_mod
  
  pr_itn <- logistic_pr_with_effect_decay(time_years, vals_for$true_pr, effect_itn_start, effect_itn_end, k, t0, k, t0)
  pr_itn_2026 <- logistic_pr_with_effect_decay(time_years, pr_itn, effect_itn_start, effect_itn_end, k, t01, k, t01)

  df <- data.frame(
    Year = time_years,
    Original_PR = vals_for$true_pr,
    itn_PR = round(pr_itn, 4),
    itn_PR_2026 = round(pr_itn_2026, 4)
  )
  df <- df[df$Year >= 2020,]
  df_first <- df[df$Year >= 2023 & df$Year <= 2026, ]
  df_sec   <- df[df$Year >= 2025.8, ]

  # === Plot for each ITN type ===
  plot(df$Year, df$Original_PR, type = "l", lwd = 2, col = "blue",
       ylim = c(0, 1),
       ylab = "Parasite Rate (PR)", xlab = "Year",
       main = paste(unique(data$district_name), "-", "cov=", j*100,"%"))

  lines(df$Year, df$itn_PR, col = "darkred", lwd = 2)
  lines(df$Year, df$itn_PR_2026, col = "green", lwd = 2)
  with(data, lines(jdate / 365 + FirstYear, pfpr, pch = 16, type = "o", col = "darkblue"))

  # Optional: Pause every 4 plots
  if (j %% 4 == 0 && j != length(average_eff$mean_percent)) {
    # Add legend after 4 plots
    par(xpd = TRUE)
    legend("top", inset = -0.1, horiz = TRUE,
           legend = c("Forecast PR", "ITN 1", "ITN 2"),
           col = c("blue", "darkred", "green"),
           lty = 1, lwd = 2, bty = "n")
    par(xpd = FALSE)

    readline("Press [Enter] to continue...")
    par(mfrow = c(2, 2))  # Reset plotting layout
  }
}

# If total plots are not a multiple of 4, add final legend
if (length(average_eff$mean_percent) %% 4 != 0) {
  par(xpd = TRUE)
  legend("top", inset = -0.1, horiz = TRUE,
         legend = c("Forecast PR", "ITN 1", "ITN 2"),
         col = c("blue", "darkred", "green"),
         lty = 1, lwd = 2, bty = "n")
  par(xpd = FALSE)
}

       



# 
#  ## Plot outputs    
#  with(vals_for, plot(time/365+FirstYear, true_pr, ylab = "PR",lwd=2, xlab = "Time", main=unique(data$district_name), type = "l", ylim = c(0,1), col="darkred"))
#  with(vals_for_cast, lines(time/365+ FirstYear, true_pr, lwd=2,col="blue") )
#  with(vals, lines(time/365+FirstYear, true_pr, lwd=2,  col="darkblue"))
#   with(data, lines(jdate/365+FirstYear, pfpr, pch=16,type = "o", col="darkblue"))
#   add_irs_history(unique(data$district_name))
#   add_itn_history(unique(data$district_name))
    
  }

```

```{r}
##pdf("itn_scenario_time_decay_cov.pdf")
#for(i in 1:length(itn_time))
for(i in 15)
  profile_itn(i, fitted_mod, data_list)
#dev.off(dev.cur())
```

```{r}
pdf("PBO_districts_cts_only.pdf")
malaria_itn_Effect <- list()
Royal_guard  <- c(75,145,106,123,2,94,92,11,142,1,105,77,117,110,111,6,33)
Permanent_dual <- c(8,35,10,60,44)
Interceptor <- c(146,118,128,26,114,23,46,24,61,57,134,131,133,45,72)
PBO <- setdiff(1:length(dist_name), c(Royal_guard,Permanent_dual,Interceptor))
for(i in Royal_guard) {
#for (i in setdiff(1:length(dist_name), c(10,27,33,35.37,42,86,95,98,99,101,140)))  {
  itn <- profile_itn(i, fitted_mod, data_list)  
  malaria_itn_Effect[[i]] <- itn  # Store each data.frame
}
dev.off()
# Combine all stored data.frames into one big data.frame
malaria_itn_eff <- do.call(rbind, malaria_itn_Effect)
# Save to CSV
write.csv(malaria_itn_eff, "../data/PBO_itn_eff.csv", row.names = FALSE)
```



